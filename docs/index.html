<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libode: libode</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libode
   </div>
   <div id="projectbrief">Easy to compile, fast ODE integrators as C++ classes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">libode </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><code>libode</code> is a library of C++ classes for solving systems of ordinary differential equations in autonomous form. All of the solvers are single-step, Runge-Kutta-like methods. There are explicit, adaptive solvers up to the ninth order. The repository also includes Rosenbrock methods, a singly-diagonal implicit Runge-Kutta (SDIRK) method, and several fully implicit Runge-Kutta methods. However, only a few of the implicit methods have solid adaptive time steppers at this point. With the current collection of solvers and features, <code>libode</code> is well suited to any non-stiff system and to stiff systems that are tightly coupled and have a known Jacobian (ones that don't require sparse or banded matrix routines). It's been useful for solving the same system a huge number of times with varying parameters, when the speed advantage of parallel C++ might be worth it.</p>
<p>The classes were originally styled after <a href="https://people.seas.harvard.edu/~chr/">Chris Rycroft</a>'s <a href="https://github.com/chr1shr/am225_examples/tree/master/1a_ode_solvers">example classes</a>. Their structure makes it easy to build a templated integrator on top of an arbitrary solver class and switch the solver/method. Implicit methods can be given a function for the ODE system's Jacobian or, if none is provided, the Jacobian is estimated using finite differences.</p>
<p>Several of the solvers and much more detail on the methods can be found in these amazing books:</p><ul>
<li>Hairer, E., NÃ¸rsett, S. P. &amp; Wanner, G. Solving Ordinary Differential Equations I: Nonstiff Problems. (Springer-Verlag, 1987).</li>
<li>Hairer, E. &amp; Wanner, G. Solving Ordinary Differential Equations II: Stiff and Differential-Algebraic Problems. (Springer, 1996).</li>
</ul>
<p>The table below lists all the solvers and gives some basic information about them. All of the solvers can be used with a custom time step selection function, but those with a built-in adaptive capability are indicated below. Papers and/or links to the derivation or original publication of the methods are often copied in the headers for the solver classes and included in the documentation. Some work still needs to be done to make the implicit methods genuinely useful, and a list of things to implement is in the <code>todo.txt</code> file.</p>
<table class="doxtable">
<tr>
<th>Method </th><th>Class Name </th><th>Header File </th><th>(ex/im)plicit </th><th>built-in adaptive? </th><th>stages </th><th>order </th><th>stability </th></tr>
<tr>
<td>Forward Euler </td><td><code>OdeEuler</code> </td><td><code><a class="el" href="ode__euler_8h.html">ode_euler.h</a></code> </td><td>explicit </td><td>no </td><td>1 </td><td>1 </td><td></td></tr>
<tr>
<td>Trapezoidal Rule </td><td><code>OdeTrapz</code> </td><td><code><a class="el" href="ode__trapz_8h.html">ode_trapz.h</a></code> </td><td>explicit </td><td>no </td><td>2 </td><td>2 </td><td></td></tr>
<tr>
<td>Strong Stability-Preserving, Order 3 </td><td><code>OdeSsp3</code> </td><td><code><a class="el" href="ode__ssp__3_8h.html">ode_ssp_3.h</a></code> </td><td>explicit </td><td>no </td><td>3 </td><td>3 </td><td></td></tr>
<tr>
<td>Runge-Kutta-Fehlberg 3(2) </td><td><code>OdeRKF32</code> </td><td><code><a class="el" href="ode__rkf__32_8h.html">ode_rkf_32.h</a></code> </td><td>explicit </td><td>yes </td><td>3 </td><td>3 </td><td></td></tr>
<tr>
<td>RK4 </td><td><code>OdeRK4</code> </td><td><code><a class="el" href="ode__rk__4_8h.html">ode_rk_4.h</a></code> </td><td>explicit </td><td>no </td><td>4 </td><td>4 </td><td></td></tr>
<tr>
<td>Runge-Kutta 4(3) </td><td><code>OdeRK43</code> </td><td><code><a class="el" href="ode__rk__43_8h.html">ode_rk_43.h</a></code> </td><td>explicit </td><td>yes </td><td>5 </td><td>4 </td><td></td></tr>
<tr>
<td>Cash-Karp </td><td><code>OdeRKCK</code> </td><td><code><a class="el" href="ode__rkck_8h.html">ode_rkck.h</a></code> </td><td>explicit </td><td>yes </td><td>6 </td><td>5 </td><td></td></tr>
<tr>
<td>Dormand-Prince 5(4) </td><td><code>OdeDoPri54</code> </td><td><code><a class="el" href="ode__dopri__54_8h.html">ode_dopri_54.h</a></code> </td><td>explicit </td><td>yes </td><td>7 </td><td>5 </td><td></td></tr>
<tr>
<td>Jim Verner's "most efficent" 6(5) </td><td><code>OdeVern65</code> </td><td><code><a class="el" href="ode__vern__65_8h.html">ode_vern_65.h</a></code> </td><td>explicit </td><td>yes </td><td>9 </td><td>6 </td><td></td></tr>
<tr>
<td>Jim Verner's "most efficent" 7(6) </td><td><code>OdeVern76</code> </td><td><code><a class="el" href="ode__vern__76_8h.html">ode_vern_76.h</a></code> </td><td>explicit </td><td>yes </td><td>10 </td><td>7 </td><td></td></tr>
<tr>
<td>Dormand-Prince 8(7) </td><td><code>OdeDoPri87</code> </td><td><code><a class="el" href="ode__dopri__87_8h.html">ode_dopri_87.h</a></code> </td><td>explicit </td><td>yes </td><td>13 </td><td>8 </td><td></td></tr>
<tr>
<td>Jim Verner's "most efficent" 9(8) </td><td><code>OdeVern98</code> </td><td><code><a class="el" href="ode__vern__98_8h.html">ode_vern_98.h</a></code> </td><td>explicit </td><td>yes </td><td>16 </td><td>9 </td><td></td></tr>
<tr>
<td>Rosenbrock 4(3) </td><td><code>OdeGRK4A</code> </td><td><code><a class="el" href="ode__grk4a_8h.html">ode_grk4a.h</a></code> </td><td>implicit </td><td>yes </td><td>4 </td><td>4 </td><td>A </td></tr>
<tr>
<td>Rosenbrock 6 </td><td><code>OdeROW6A</code> </td><td><code><a class="el" href="ode__row6a_8h.html">ode_row6a.h</a></code> </td><td>implicit </td><td>no </td><td>6 </td><td>6 </td><td>A </td></tr>
<tr>
<td>Backward Euler </td><td><code>OdeBackwardEuler</code> </td><td><code><a class="el" href="ode__backward__euler_8h.html">ode_backward_euler.h</a></code> </td><td>implicit </td><td>no </td><td>1 </td><td>1 </td><td>L </td></tr>
<tr>
<td>Gauss 6th Order </td><td><code>OdeGauss6</code> </td><td><code><a class="el" href="ode__gauss__6_8h.html">ode_gauss_6.h</a></code> </td><td>implicit </td><td>not yet </td><td>3 </td><td>6 </td><td>A </td></tr>
<tr>
<td>Lobatto IIIC 6th Order </td><td><code>OdeLobattoIIIC6</code> </td><td><code><a class="el" href="ode__lobatto__iiic__6_8h.html">ode_lobatto_iiic_6.h</a></code> </td><td>implicit </td><td>not yet </td><td>4 </td><td>6 </td><td>L </td></tr>
<tr>
<td>Radau IIA 5th Order </td><td><code>OdeRadauIIA5</code> </td><td><code><a class="el" href="ode__radau__iia__5_8h.html">ode_radau_iia_5.h</a></code> </td><td>implicit </td><td>not yet </td><td>3 </td><td>5 </td><td>L </td></tr>
<tr>
<td>Geng's Symplectic 5th Order </td><td><code>OdeGeng5</code> </td><td><code><a class="el" href="ode__geng__5_8h.html">ode_geng_5.h</a></code> </td><td>implicit </td><td>no </td><td>3 </td><td>5 </td><td>A? </td></tr>
<tr>
<td>SDIRK 4(3) </td><td><code>OdeSDIRK43</code> </td><td><code><a class="el" href="ode__sdirk__43_8h.html">ode_sdirk_43.h</a></code> </td><td>implicit </td><td>yes </td><td>4 </td><td>4 </td><td>L </td></tr>
</table>
<h1><a class="anchor" id="sec_compiling"></a>
Compiling</h1>
<h2><a class="anchor" id="sec_compiling_short"></a>
Short Instructions</h2>
<ol type="1">
<li>Copy the <code>_config.mk</code> file to <code>config.mk</code>.</li>
<li>Edit any of the compiler settings in your new <code>config.mk</code> file as necessary (specify which compiler to use and any compiling flags you want).</li>
<li>Run <code>make</code> in the top directory where the Makefile is.</li>
<li>If anything weird happens, tell me.</li>
<li>Execute the <code>run_all_tests.sh</code> script to check that things are working (Python with numpy and matplotlib are needed for plotting). If you want, also execute <code>run_all_examples.sh</code> to run some example solvers.</li>
<li>Create derived classes and link to the library with <code>-I&lt;path&gt;/libode/src -L&lt;path&gt;/libode/bin -lode</code>, replacing <code>&lt;path&gt;</code> with the path to the directory above <code>libode</code> on your computer.</li>
</ol>
<h2><a class="anchor" id="sec_compiling_long"></a>
Longer Instructions</h2>
<p><code>libode</code> is meant to provide straightforward access to class-based ODE solvers without dependencies or specialized compiling processes. The library is free-standing and there is only one step to take before simply running the Makefile and being done with it. Consequently, the library is also slim on features and doesn't provide things like sparse matrices and dense output. For many systems of ODEs, though, <code>libode</code> should make it easy to build an integrator and enjoy the speed of C++ and <a href="https://en.wikipedia.org/wiki/OpenMP">openmp</a> without the headaches of large, complex packages.</p>
<p>First, before any of the <code>libode</code> classes can be compiled, you must copy the <code>_config.mk</code> file to <code>config.mk</code> and edit that file to specify the compiler settings you'd like the Makefile to use. This shouldn't be complicated. If you are using a current version of the GNU C++ compiler (g++), the contents of the template config file can likely be used without modification. There are also commented lines for use with the Intel C++ compiler (icpc), if that is available. To compile all the classes, simply run <code>make</code> in the top directory.</p>
<p>The Makefile compiles all of the necessary code into the <code>obj</code> folder, then archives it in the <code>bin</code> directory as a file called <code>libode.a</code>. To use the solvers, you can link <code>libode.a</code> (in the <code>bin</code> directory) or the object files directly (in the <code>obj</code> directory) when compiling your derived class. You must also include the header files in the <code>src</code> directory, as there is not a single header file for the library. All of the classes have their header file name displayed in the documentation and in the table above. Linking the solver classes requires something like</p>
<p><code>-I&lt;path&gt;/libode/src -L&lt;path&gt;/libode/bin -lode</code></p>
<p>when compiling derived code, with <code>&lt;path&gt;</code> replaced by path elements leading to the libode directory. For some examples of how to link a derived class to <code>libode</code> and create a program to run integrations, see the examples folder.</p>
<p>Test programs are compiled with <code>make tests</code> and they can all be run in sequence with the <code>run_all_tests.sh</code> script (which uses Python to plot the test results).</p>
<h2><a class="anchor" id="sec_compiling_cmake"></a>
Compiling with CMake</h2>
<p>Whe library can be built with CMake as well. You can start CMake with the following script </p><div class="fragment"><div class="line">.  run_cmake.sh</div>
</div><!-- fragment --><p> This script creates an folder <code>build</code>, compiles the library, installs it locally and creates a package.</p>
<p>Here is an example of an file <code>CMakeLists.txt</code> to show how to use the <b>ode</b> library:</p>
<div class="fragment"><div class="line">cmake_minimum_required(VERSION 3.15)</div>
<div class="line">project(&quot;ODETest&quot; VERSION 0.9 DESCRIPTION &quot;A project with the libode library&quot;)</div>
<div class="line"> </div>
<div class="line">set(CMAKE_CXX_STANDARD 11)</div>
<div class="line">set(CMAKE_CXX_STANDARD_REQUIRED ON)</div>
<div class="line"> </div>
<div class="line"># It is a local prefix.</div>
<div class="line"># Comment it out if you want to use the default prefix.</div>
<div class="line">set(CMAKE_PREFIX_PATH &quot;$ENV{HOME}/install&quot;)</div>
<div class="line"> </div>
<div class="line">find_package(ode CONFIG REQUIRED)</div>
<div class="line"> </div>
<div class="line">add_executable(${PROJECT_NAME})</div>
<div class="line">target_sources(${PROJECT_NAME}</div>
<div class="line">    PRIVATE</div>
<div class="line">        my_ode_test.cpp # These are the names of the source files.</div>
<div class="line">)</div>
<div class="line">target_link_libraries(${PROJECT_NAME} PRIVATE ode::ode)</div>
</div><!-- fragment --><h1><a class="anchor" id="sec_usage"></a>
Using the Solvers</h1>
<h2><a class="anchor" id="subsec_classes"></a>
Define a Class</h2>
<p>To integrate a specific system of ODEs, a new class must be created to inherit from one of the solver classes. This new inheriting class must</p><ol type="1">
<li>Define the system of ODEs to be solved by implementing the <code>ode_fun()</code> function. This is a virtual function in the base classes. Once implemented, it's used by the stepping and solving functions.</li>
<li>Set initial conditions using the <code>set_sol()</code> function.</li>
<li>Optionally implement the <code>ode_jac()</code> function for implicit methods. This is also a virtual function in the base classes. If it's not overridden but is needed, a (crude) finite-difference estimate of the Jacobian is used.</li>
</ol>
<p>For flexibility, the derived class could be a template, so that the solver/method can be chosen when the class is constructed. Other than defining the system of equations and setting initial conditions, the derived class can store whatever information and implement whatever other methods are necessary. This could be something simple like an extra function for setting initial conditions. It could, however, comprise any other system that needs to run on top of an ODE solver, like the spatial discretization of a big PDE solver.</p>
<h2><a class="anchor" id="subsec_integrate"></a>
Call an Integration Function</h2>
<p>Each solver has a <code>step</code> method that can be used to integrate a single step with a specified step size. Each solver class also has a <code>solve_fixed()</code> method and, if it's an adaptive class, a <code>solve_adaptive()</code> method. These functions return nothing and both have the same four call signatures:</p>
<ol type="1">
<li><p class="startli"><code>void solve_fixed (double tint, double dt)</code></p>
<p class="startli">Simply advances the solution for a specified length of the independent variable. The independent variable is assumed to be time, so <code>tint</code> is the integration time and <code>dt</code> is the time step to use (or the initial time step for adaptive solves).</p>
</li>
<li><p class="startli"><code>void solve_fixed (double tint, double dt, const char *dirout, int inter)</code></p>
<p class="startli">Integrates for a duration of <code>tint</code> using time step (or initial time step) <code>dt</code> and writes solution values after every <code>inter</code> steps to the directory <code>dirout</code>. For example, if <code>inter</code> is one, the solution at every step is written to file. If <code>inter</code> is two, every other step is written.</p>
</li>
<li><p class="startli"><code>void solve_fixed (double tint, double dt, unsigned long nsnap, const char *dirout)</code></p>
<p class="startli">Integrates and writes <code>nsnap</code> even spaced snapshots of the solution into the directory <code>dirout</code>.</p>
</li>
<li><p class="startli"><code>void solve_fixed (double dt, double *tsnap, unsigned long nsnap, const char *dirout)</code></p>
<p class="startli">Integrates and writes snapshots at the times specified in <code>tsnap</code> into the directory <code>dirout</code>.</p>
</li>
</ol>
<p>If these functions aren't enough, you could always write your own loop calling the <code>step()</code> function directly.</p>
<h2><a class="anchor" id="subsec_padapt"></a>
Flexibly Adapt the Time Step</h2>
<p>Some of the solvers have built-in adaptive time steppers. They automatically choose time steps by comparing the solution for a single step with that of an embedded, lower order solution for the step and computing an error estimate. The algorithm for this is well described in the books referenced above. If, however, there is another way that the time step should be chosen for a system, a new selection algorithm can be used with <b>any</b> of the solvers. If the virtual function <code>dt_adapt()</code> is overridden, it will be used to select the time step in the <code>solve_adaptive()</code> functions.</p>
<p>Rejecting an adaptive step is easy. During an adaptive solve, the virtual <code>is_rejected()</code> function is called after every step. If it returns <code>true</code>, the step is rejected. If it returns <code>false</code>, the step is accepted. Either way, <code>dt_adapt()</code> computes the next time step size and the solver proceeds. So, at minimum, an adaptive solver with time step rejection needs to have its <code>dt_adapt()</code> and <code>is_rejected()</code> functions implemented. The embedded Runge-Kutta methods have these functions built in, but they can be overridden.</p>
<p>If it's easier to compute the next time step and determine whether the step is rejected all at once, the virtual <code>adapt()</code> function can be implemented. It should store the next time step and store a boolean for rejection. Then <code>dt_adapt()</code> and <code>is_rejected()</code> simply return those stored values. This is how the embedded Runge-Kutta methods are structured because the same information determines the next step size and rejection/acceptance of the current step.</p>
<p>The point is to make time step selection totally flexible if the embedded Runge-Kutta algorithm isn't suitable. For example, this flexibility has been used to set the time step based on stability thresholds of PDE discretizations like the CFL condition for advection or the von Neumann condition for simple diffusion schemes. Prescribing the adaptive time step based on these conditions, then using <code>solve_adaptive()</code>, can provide huge speed boosts.</p>
<h2><a class="anchor" id="extra"></a>
"Extra" Functions During Solves</h2>
<p>There is a straightforward way to supplement the built-in solver functions and execute extra code at different points during solves. There are five "extra" functions, which are empty virtual functions that can be overridden by the derived class:</p>
<ol type="1">
<li><p class="startli"><code>before_solve ()</code></p>
<p class="startli">Executed at the beginning of any <code>solve_fixed()</code>/<code>solve_adaptive()</code> call.</p>
</li>
<li><p class="startli"><code>after_step (double t)</code></p>
<p class="startli">Executed after every step while the solve function is running. The <code>t</code> input is the current "time" of the system, or the value of the independent variable. Although the system must be in autonomous form, the classes track the independent variable as a convenience.</p>
</li>
<li><p class="startli"><code>after_capture (double t)</code></p>
<p class="startli">Executed each time the state of the system is captured during the second version of <code>solve_fixed()</code>/<code>solve_adaptive()</code> above (the one with the <code>inter</code> argument). This function is similar to <code>after_step()</code>, but if the output interval is greater than one, it is only called when output is stored. The <code>t</code> input is the current "time" of the system, or the value of the independent variable. Although the system must be in autonomous form, the classes track the independent variable as a convenience.</p>
</li>
<li><p class="startli"><code>after_snap (std::string dirout, long isnap, double t)</code></p>
<p class="startli">Executed after every snapshot in the solver functions that use snapshot output (call signatures 3 and 4 above). <code>dirout</code> is the output directory and <code>isnap</code> is the snapshot count (starting from 0). The <code>t</code> input is the current "time" of the system, or the value of the independent variable.</p>
</li>
<li><p class="startli"><code>after_solve ()</code></p>
<p class="startli">Executed at the end of any <code>solve_fixed()</code>/<code>solve_adaptive()</code> call.</p>
</li>
</ol>
<p>These functions are meant to be very general. They can be used to implement a customized output/storage procedure, print updates, set and reset system variables, or anything else. If they are not overridden, they will do nothing. </p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"/>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
